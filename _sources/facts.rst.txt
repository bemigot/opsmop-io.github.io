.. image:: opsmop.png
   :alt: OpsMop Logo

.. _facts:

Facts
-----

OpsMop has several ways to learn about the running system.  These are collectively known as
'Facts'. 

Users can write their own 'Facts' classes, or use one of the many included ones:

* Platform
* UserFacts
* FileTests

All facts can be used in :ref:`conditionals`, :ref:`hooks` as well as :ref:`templates` - in fact, they are just Python
instances with functions, so you can use them anywhere.  

Here's a basic example from :ref:`platform`:

.. code-block:: python

    def set_resources(self):
        darwin = (Platform.system() == "Darwin")
        return Resources(
            Echo("My platform is {{ Plaform.system() }}"),
            Echo("This is OS X.", when=darwin)
        )

Or as we showcased in :ref:`hooks`, it's also easy to attach a conditional to a whole *Role*, or even a *Policy*.  For most
use cases, we definitely prefer this format:

.. code-block: python

    class FooRole(Role):

        def should_process_when(self):
            return Platform.system() != "Darwin"

        # ...

.. _platform:

Platform
========

Platform Facts tell you something about the OS or Machine you are running on.

More platform facts will be added frequently, and also make easy first pull requests.
See :ref:`development` if you are interested in adding something.

.. list-table::
   :header-rows: 1

   * - Function
     - Description
   * - default_package_provider()
     - used internally by the Package type
   * - default_service_provider()
     - used internally by the Package type
   * - release()
     - from `python's platform module <https://docs.python.org/3/library/platform.html>`_
   * - system()
     - from `python's platform module <https://docs.python.org/3/library/platform.html>`_
   * - version()
     - from `python's platform module <https://docs.python.org/3/library/platform.html>`_

We've already included some examples above, and the rest should be self explanatory.
See :ref:`debugging_facts` if you are trying to match up values while writing your *Policy* files.

Chaos
=====

Chaos facts are intended for use in Chaos Engineering. They return random values, allowing
you to randomly perform steps, or sometimes even randomly misconfigure your systems. 

While we're not responsible for anything you do with OpsMop, we would like to remind you now that 
with great power comes great responsibility.

.. list-table::
   :header-rows: 1

   * - Function
     - Description
   * - choice(a,b,c,d,e)
     - randomly returns one of the parameters
   * - random()
     - returns a float between 0 and 1

Example:

.. code-block:: python

    class FooRole(Role):

        def should_process_when(self):
            return (Chaos.random() < 0.25)

        def set_resources(self):
            # ...

Or in a Jinja2 template::

    {% if Chaos.random() < 0.33 %}
    blocksize=4091 # misconfigured! whooohoo, sneaky
    {% else %}
    blocksize=4092
    {% endif %}

.. _file_tests:

FileTests
=========

FileTest facts let you ask questions about files and directories.

These are functions that take one or more path names and return booleans, strings,
or integers.

.. list-table::
   :header-rows: 1

   * - Function
     - Description
   * - exists(f)
     - Does the path exist? - True/False
   * - executable(f)
     - Is the path executable? - True/False
   * - is_file(f)
     - Is the path a file? - True/False
   * - is_directory(f) 
     - Is the path a directory? - True/False
   * - mode(f)
     - Return the numeric mode of the path, ex: 0o770
   * - user(f)
     - Return the owner user of the path
   * - group(f)
     - Return the owner group of the path
   * - checksum(f)
     - Return the sha1sum of the path
   * - checksum_string(s)
     - Return the sha1sum of a string (bonus)

Example:

.. code-block:: python

    class LinuxSetup(Role):

        def should_process_when(self):
            return (Platform.system() != "Darwin")

        def set_resources(self):
            # ...

Example:

.. code-block:: python

    class Foo(Role):


        def set_resources(self):
            darwin = (Platform.system() == "Darwin")
            return Resources(
                # ...
                Echo("this only runs on OS X", when=darwin)
                #..
            )

Example (Jinja2 template):

.. code_block:: python

    class Foo(Role):

        def set_resources(self):
            return Resources(
                File("/etc/foo.cfg", from_template="templates/foo.cfg.j2"),
            )

.. code-block::

    # This file is programatically generated by OpsMop: templates/foo.confg.j2

    example_config_file=made_up
    parameters=imaginary

    {% if Platform.system() == 'Darwin' %}
    asdf=1234
    {% else %}
    asdf=5678
    {% endif %}
    
    jklm=101010101010

.. note::
    Pretty much all of the FileTest facts take parameters, which means they
    can't be debugged by :ref:`module_debug_facts`. Using them in a template
    or Echo statement can be a good way to debug if you need to.

.. _user_facts:

UserFacts
=========

UserFacts are easily user-customizable facts that you can use *WITHOUT* making new Python classes.
They are generated by scanning files in /etc/opsmop/facts.d/.

If a file is not executable, the file will be interpreted as a dictionary in either JSON
or YAML format.

If the file is executable, the file will be evaluated, and the output will be evaluated
as a dictionary in either JSON or YAML format.  The program, in this case, can be written
in any language at all.

For a full demo of this, see `user_facts.py <https://github.com/opsmop/opsmop-demo/blob/master/content/user_facts.py>`.

UserFacts are usually calculated only once per run, for efficiency.  The example includes an invalidate() call
if you want to learn how to re-evaluate the facts.

To test UserFacts, see :ref:`debugging_facts`.

Access looks like this:

.. code-block: python::

   UserFacts.variable_name

In Python, nested array and dictionary values look normal:

.. code-block: python::

   UserFacts.variable_name.sub_element[2]

In Jinja2, you can of course also use '.'::

   UserFacts.variable_name.sub_element[2]

.. note:

   Pro-tip: if you want your *Policies* to react dynamically to the configuration of the system, you may
   think about writing a dynamic fact that queries cloud tags. This could be inefficient if you have a lot
   of instances.  Consider having your deployment process drop a file into /etc/opsmop/facts.d instead.

.. _debugging_facts:

Debuging Facts
==============

For modules other than FileTest, here's a quick way to show Fact values::

     python -m opsmop.facts.platform
     python -m opsmop.facts.user_facts

Alternatively see :ref:`module_debug_facts` to show the same things while running a *Policy*.

Custom Facts
============

If you don't want to use :ref:`user_facts`, you can also write your own fact classes.  This is a little more
involved, but still easy.

You will need to extend opsmop.core.policy.Policy to inject the new facts into the Template namespace *IF* you want
to surface those Fact classes in the Jinja2 template environment.  Then, in your policy files, always use your
new base class, like AcmeCorpPolicy, instead of the Policy object that ships with OpsMop.

You will also want to make sure you import the Facts so you can use them in conditionals in addition to templates.

See also :ref:`development`.

Want To Add New Facts?
======================

Contribution of new facts (particularly OS/hardware related facts) to the main fact code is quite welcome.  
See :ref:`development`. Thank you!



